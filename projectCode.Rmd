---
title: "Project"
author: "Kiran Karpurapu"
date: "11/22/2016"
output: pdf_document
---

<!-- https://rstudio-pubs-static.s3.amazonaws.com/33876_1d7794d9a86647ca90c4f182df93f0e8.html -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# setting up the libraries
# require(caTools)
library(gdata)
library(car)
library(caret)
library(caTools)
```

```{r}
# setting the working directory
# /Users/kkiran/Desktop/fall_2016/fds/project/MovieScorePredictor/data
setwd('/Users/kkiran/Desktop/fall_2016/fds/project/MovieScorePredictor/data/')
movieData = read.xls("movie_data.xls")
head(movieData)
```

Loaded the data into a data frame 'movieData'

```{r}
# identifying top 10 genres out of all the 26 genres to make the work more focussed

# gernes present in the data:
# 'Sci-Fi', 'Crime', Romance', Animation', Music', Comedy', War', genres', Horror', Film-Noir', Adventure', News', Reality-TV', Thriller', Western', Mystery', Short', Drama', Action', Documentary', Musical', History', Family', Fantasy', Game-Show', Sport', Biography'

movieCount <- c()

for(i in 38:64)
{
  movieCount[i - 37] = sum(movieData[,i]);
}
movieCount

genreNames <- as.vector(colnames(movieData)[38:64])
genreNames

genreNames <- as.vector(genreNames)

genreMovieCount <- data.frame(genreNames, movieCount)
plot(genreMovieCount$genreNames, genreMovieCount$movieCount, main="Genre Distribution",	xlab="Genre ", ylab=" Movies Made")
```

We can see that not all the genres have a considerable number of movies made in them, so we decided to extract the top 11 genres that have the most number of movies made in those particular genres.

```{r}
genreMovieCountSorted <- genreMovieCount[order(-movieCount),] 
genreMovieCountSorted <- genreMovieCountSorted[c(1:10),]
plot(genreMovieCountSorted$genreNames, genreMovieCountSorted$movieCount, main="Filtered Genre Distribution",	xlab="Genre ", ylab=" Movies Made")

```

Now we have to remove the data for all the other genres from the data set, also we can delete the last column from the data set because it is repeated
```{r}

movieData <- movieData[,-65]
columnNames <- colnames(movieData)
columnNames <- columnNames[1:37]

selectedNames <- genreMovieCountSorted$genreNames

columnNames <- as.vector(columnNames)
selectedNames <- as.vector(selectedNames)

names <- c(columnNames, selectedNames)
names

movieData1 <- subset(movieData, select = names)
# for(i in 38:47)
# {
#   print(c(colnames(movieData1[i]), sum(movieData1[,i])));
# }
```
Now movieData1 has the data about the genres that we are interested only. The next step is to clean the data by removing rows that dont have a considerable amount of data. If the facebook likes are missing, we can get those details from other rows. (Although the likes number is not constant, this approach can give us a decent estimate of the number of likes).

```{r}

row.has.na <- apply(movieData1, 1, function(x){any(is.na(x))})
numberOfNAs <- sum(row.has.na)

print (c("can remove ", numberOfNAs , "from the table"))
movieData1 <- na.omit(movieData1)
```

```{r}
NAcounter <- 0
indicesToRemove <- c()
index <- 1
# this is the working version 
for (i in 1 : nrow(movieData1)) {
  if (any(movieData1[i,] == "N/A")) {
     print (c(i, "yes" , movieData1[i,]))
    indicesToRemove[index] = i;
    index <- index + 1
    NAcounter <- NAcounter + 1
  } else
    print ("no")
}

print(length(indicesToRemove))
print(indicesToRemove)
print(c("total number of nulls", NAcounter))
```

```{r}
#removing the rows that have NA in them
movieData2 <- movieData1[-indicesToRemove,]
# Now, movieData2 has no NA in any of the rows.

movieData2[movieData2==""] <- NA
row.has.na <- apply(movieData2, 1, function(x){any(is.na(x))})
numberOfNAs <- sum(row.has.na)
print(c("There are ",numberOfNAs, " rows with empty cells, so we are removing them"))
movieData2 <- na.omit(movieData2)
```


```{r}
#couting the profits of a movie by subtracting the budget from the gross
movieData2$profits <- movieData2$gross - movieData2$budget
movieData3 <- movieData2[,c(c(1:13),48, c(14:47))]
```


```{r}

#coverting factor to int array
movieData3$tomatoUserRating <- as.numeric(as.character(movieData3$tomatoUserRating))
movieData3$tomatoRating <- as.numeric(as.character(movieData3$tomatoRating))
movieData3$tomatoReviews <- as.numeric(as.character(movieData3$tomatoReviews))
movieData3$tomatoFresh <- as.numeric(as.character(movieData3$tomatoFresh))
movieData3$tomatoRotten <- as.numeric(as.character(movieData3$tomatoRotten))
movieData3$tomatoUserMeter <- as.numeric(as.character(movieData3$tomatoUserMeter))
movieData3$tomatoUserReviews <- as.numeric(as.character(movieData3$tomatoUserReviews))
movieData3$imdbVotes <- as.numeric(as.character(movieData3$imdbVotes))
movieData3$Metascore <- as.numeric(as.character(movieData3$Metascore))
```

```{r}
# checking the correlation
str(movieData3)
cor(movieData3$imdb_score, movieData3[,c(7,12:26,38)], use = "pairwise.complete.obs")
```

```{r}
cNames <- paste("movieData3$",colnames(movieData3)[c(7,12:26,38)], sep = "")
cNames
#formula contains all the columns that we want to include in the model
formula <- as.formula(paste("y ~ ", paste(cNames, collapse= "+")))
formula
```


```{r}
#choice of linear regression vs logistic regression
# Linear regression: When the outcome(dependent variable) is continuous, i.e. infinite number of possibilities.
# Logistic regression: When the outcome(dependent variable) has a limited set of values.

#because we are trying to predict the IMDB score of a movie and theoritically the score can have an infinite number of possibilities, we are chosing linear regression over logisitic regression
#linear regression


lmfit1.movieData <- lm(movieData3$imdb_score ~ movieData3$cast_total_facebook_likes + movieData3$gross + movieData3$budget + movieData3$num_critic_for_reviews +movieData3$num_user_for_reviews + movieData3$tomatoUserRating + + movieData3$tomatoRating + movieData3$tomatoReviews + movieData3$tomatoFresh + movieData3$tomatoUserMeter + movieData3$tomatoUserReviews + movieData3$num_voted_users +  movieData3$imdbVotes + movieData3$duration ,data = movieData3)

summary(lmfit1.movieData)

vif(lmfit1.movieData)
```
Looking at the Variance Inflation Factor of the fitted model, we can see that imdbVotes and num_voted_users are two largest VIFs. so we try to eliminate them and make the model again.

```{r}
 lmfit2.movieData <- lm(movieData3$imdb_score ~ movieData3$cast_total_facebook_likes + movieData3$gross + movieData3$budget + movieData3$num_critic_for_reviews +movieData3$num_user_for_reviews + movieData3$tomatoUserRating + + movieData3$tomatoRating + movieData3$tomatoReviews + movieData3$tomatoFresh + movieData3$tomatoUserMeter + movieData3$tomatoUserReviews + movieData3$duration ,data = movieData3)

summary(lmfit2.movieData)

vif(lmfit2.movieData)
# we can see that the std error for the parameter estimates gets smaller.
```

```{r}
#calculating the MSFE and MAD for the predicted values
predictedScore <- predict(lmfit2.movieData)
predictedScore
RSFE_v <- movieData3$imdb_score - predictedScore
RSFE_v
RSFE <- sum(RSFE_v)
RSFE
absRSFE <- abs(RSFE)
absRSFE
length(RSFE_v)
MAD <- absRSFE / length(RSFE_v)
MAD
print(c("Mean Absolute Deviation" , MAD))
```

```{r}
# Analysing the linear regression model
```

```{r}

wssplot <- function(data, nc=15, seed=1234) {
  wss <- (nrow(data)-1)*sum(apply(data,2,var))
  bss <- (nrow(data)-1)*sum(apply(data,2,var))
  for (i in 2:nc) {
    set.seed(seed)
    wss[i] <- sum(kmeans(data[,c(7,12:26,38)], centers=i)$withinss)
    bss[i] <- sum(kmeans(data[,c(7,12:26,38)], centers=i)$betweenss)
    }
  
  plot(1:nc, wss, type="b", xlab="Number of Clusters",
       ylab="Within groups sum of squares")
  plot(1:nc, bss, type="b", xlab="Number of Clusters",
       ylab="Between groups sum of squares")
  }

wssplot(movieData3, nc=35) 
```

```{r}
set.seed(101) 
sample = sample.split(movieData3, SplitRatio = .75)
train = subset(movieData3, sample == TRUE)
test = subset(movieData3, sample == FALSE)
```

```{r}
#using Kmeans clustering

dim(train)
k.means.fit <- kmeans(train[,c(7,12:26,38)], 20)
attributes(k.means.fit)
k.means.fit$centers
k.means.fit$cluster
k.means.fit$size

kmeansPrediction <- as.data.frame(k.means.fit$centers)
kmeansPrediction <- kmeansPrediction[,5]
kmeansPrediction


closest.cluster <- function(x) {
  cluster.dist <- apply(k.means.fit$centers, 1, function(y) sqrt(sum((x-y)^2)))
  print(c( "cluster: " ,(which.min(cluster.dist)[1]), kmeansPrediction[which.min(cluster.dist)[1]]))
  print( kmeansPrediction[which.min(cluster.dist)[1]])
  return (kmeansPrediction[which.min(cluster.dist)[1]])
}

clusters2 <- apply(test[,c(7,12:26,38)], 1, closest.cluster)


RSFE_v1 <- test$imdb_score - clusters2
RSFE_v1
RSFE1 <- sum(RSFE_v1)
RSFE1
absRSFE1 <- abs(RSFE1)
absRSFE1
length(RSFE_v1)
MAD1 <- absRSFE1 / length(RSFE_v1)
MAD1
print(c("Mean Absolute Deviation for prediction using K means clustering" , MAD1))
print(c("Mean Absolute Deviation for prediction using Linear Regression" , MAD))
```